# :nodoc: namespace
module SpStore

# API implemented by a S chip (slow processor that holds state across reboots).
module SChip
  # Resets the S chip to the initial power-up state.
  #
  # After this call, the chip must be taken through the S-P boot sequence, by
  # calling boot.
  def reset
    
  end
  
  # The second step of the S-P boot sequence.
  #
  # Args:
  #   encrypted_nonce:: the encrypted nonce generated by the P Chip in the first
  #                     step of the boot sequence; returned by PChip#boot_start
  #   nonce_hmac:: the nonce HMAC generated by the P chip in the first step of
  #                the boot sequence; returned by PChip#boot_start
  #
  # Returns the following:
  #   * root hash of the storage hash tree
  #   * HMAC of the root hash and the FPGA nonce keyed under the FPGA's
  #     symmetric key, and
  #   * the private endorsement key, encrypted under the FPGA's symmetric key
  #
  # Raises:
  #   RuntimeError:: if the boot nonce HMAC doesn't match the decrypted nonce
  #
  # Note: under normal operation, the root hash can also come from untrusted
  #       storage. However, having the card provide it can help the server
  #       recover from a power failure.
  def boot(encrypted_nonce, nonce_hmac)
    
  end
  
  # The PUF syndrome for the P chip that this S chip is paired with.
  #
  # The information does not need integrity guarantees, and is only stored in
  # the S chip for convenience.
  def puf_syndrome
    
  end
  
  # The Endorsement Certificate for the S-P chip pair.
  #
  # The information does not need integrity guarantees, and is only stored in
  # the S chip for convenience.
  def endorsement_certificate
    
  end
end  # class SpStore::SChip

end  # namespace SpStore
